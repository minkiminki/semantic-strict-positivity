Require Import FunctionalExtensionality ProofIrrelevance ClassicalDescription.
Require Import ClassicalChoice ChoiceFacts.
Require Import Coq.Logic.Eqdep_dec.
Require Import Program.
Set Implicit Arguments.
Set Automatic Coercions Import.
Require Import ssp2 combinator2 fixpoint2.

Arguments morder {M y} x OR.
Arguments msorder {M y} x OR.

Ltac mdestruct x x' := try (rewrite <- (destruct_correct1 x) in *; remember (Mfixpoint_destruct x) as x' eqn : _EQ; clear _EQ; clear x; simpl in x').

Ltac order_rewrite := try rewrite order_correct in *.

Ltac minduction x := apply (Mfixpoint_ind x).

Ltac msinduction x := apply (Mfixpoint_s_ind x).


Module Tree.

Inductive tree : Type :=
| node : list tree -> tree.

Inductive well_founded : tree -> Prop :=
| wf_leaf : well_founded (node nil)
| wf_internal hd tl (WHD: well_founded hd) (WTL: well_founded (node tl)) :
                      well_founded (node (cons hd tl)).

Theorem tree_well_founded x : well_founded x.
Proof.
  induction x.
Abort.

End Tree.


Module Tree_SSP.

Definition tree_gen : SSPF.t := List_sspf.

Definition tree : Type := Mfixpoint tree_gen.

Definition node (l: list tree) : tree := Mfix_mk tree_gen l.

Definition tree_destruct (t: tree) : list tree :=
  Mfixpoint_destruct t.

Inductive well_founded : tree -> Prop :=
| wf_leaf : well_founded (node nil)
| wf_internal hd tl (WHD: well_founded hd) (WTL: well_founded (node tl)) :
                      well_founded (node (cons hd tl)).

Theorem tree_well_founded x : well_founded x.
Proof.
  minduction x. intros. simpl in IND.
  induction m.
  - apply wf_leaf.
  - apply wf_internal.
    + apply IND. simpl. auto.
    + apply IHm. intros.
      apply IND. simpl. auto.
Qed.

End Tree_SSP.


Module Option_Nat.

Definition nat := Mfixpoint (Option_sspf).

Definition O := Mfix_mk Option_sspf None.
Definition S x := Mfix_mk Option_sspf (Some x).

Definition induction_principle n (P: nat -> Prop) (PO : P O) (PS : forall n, P n -> P (S n)) : P n.
Proof.
  minduction n. intros. destruct m.
  - apply PS. apply IND. constructor.
  - apply PO.
Qed.

Check Mfixpoint_fn.

Definition fibonacci_gen (n: nat) (f: forall m, s_order_Mfix m n-> Datatypes.nat) :=
match s_ordered_destruct n with
| None => 1
| Some (msorder n' pf1) =>
  match s_ordered_destruct n' with
  | None => 1
  | Some (msorder n'' pf2) => (f n' pf1) + (f n'' (link_order pf2 pf1)) end end.

Definition fibonacci : nat -> Datatypes.nat := Mfixpoint_s_fn fibonacci_gen. 

Lemma fibonacci_0 : fibonacci O = 1.
Proof.
  unfold fibonacci. rewrite Mfixpoint_s_fn_correct.
  unfold fibonacci_gen. unfold O.
  rewrite Mfixpoint
  rewrite 
  destruct (s_ordered_destruct O)


unfold fibonacci_gen. unfold O. unfold Mfixpoint_s_fn. unfold Fix.
  unfold Fix_F. unfold Fix_F.

  msimpl.
  auto.
Qed.

Lemma fibonacci_1 : fibonacci (S O) = 1.
Proof.
  unfold fibonacci, mfix_fnd, O, S.
  msimpl.
  auto.
Qed.

Lemma fibonacci_SS x : fibonacci (S (S x)) = fibonacci x + fibonacci (S x).
Proof.
  unfold fibonacci, mfix_fnd, O, S.
  msimpl.
  destruct (@mfix_destruct (Prod Option_sspf (Const Datatypes.nat))
        (@mfix_fn Option_sspf (vfx Option_sspf Datatypes.nat)
           (fun (mfx : option (Mfixpoint Option_sspf))
              (mvfx : option (vfx Option_sspf Datatypes.nat)) =>
            Mfix_mk (Prod Option_sspf (Const Datatypes.nat))
              (@pair (option (vfx Option_sspf Datatypes.nat)) Datatypes.nat mvfx
                 (fibonacci_gen mfx mvfx))) x)).
  auto.
Qed.
